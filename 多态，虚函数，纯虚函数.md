##### 多态，虚函数，纯虚函数

###### 多态

**多态就是函数调用的多种形态**，使用多态能够使得不同的对象去完成同一件事时，产生不同的动作和结果。不同的类型对象，去完成同一件事情，产生的动作是不一样的。

多态又分为静态多态和动态多态：
(1)静态多态，也称为静态绑定或前期绑定(早绑定)：函数重载和函数模板实例化出多个函数（本质也是函数重载）。静态多态也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。

(2)动态多态，也称为动态绑定或后期绑定(晚绑定)：在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，即运行时的多态。在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。

父类指针或引用指向父类，调用的就是父类的虚函数
父类指针或引用指向子类，调用的就是子类的虚函数
————————————————————————————————

###### **为什么动态多态无法在编译时就确定**：

在编译的时候编译器并不知道用户选择的是哪种类型的对象。如果不是虚函数,则采用静态绑定,函数体与函数调用在程序运行之前（编译期间）就绑定了。
当函数声明为虚函数时,如果使用指针或引用的形式，那么由于指针指向的对象不确定是基类还是派生类，那么编译器就无法采用静态绑定，所以就只有通过动态绑定的方式。因此编译器通过创建一个虚函数表存放虚函数的地址,在运行时,编译器通过虚函数指针在虚函数表中找到正确的函数版本，然后调用。

###### 多态的构成条件

多态是指不同继承关系的类对象，去调用同一函数，产生了不同的行为。在继承中要想构成多态需要满足两个条件：

1. 必须通过基类的指针或者引用调用虚函数。
2. 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。

###### 虚函数

定义一个函数为虚函数，不代表函数为不被实现的函数。

```c++
class A
{
public:
	virtual void Print(){
		cout<<"A::Print"<<endl;
}
};
```

定义它为虚函数是为了允许用基类的指针来调用子类的这个函数。

1. 只有**类的非静态成员函数前可以加virtual**，**普通函数前不能加virtual**。
2. 虚函数这里的virtual和虚继承中的virtual是同一个关键字，但是它们之间没有任何关系。**虚函数这里的virtual是为了实现多态**，而**虚继承的virtual是为了解决菱形继承的数据冗余和二义性**。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。



```c++
class A{
public:
	virtual void foo()
	{
		cout<<"A:foo() is called"<<endl;
	}
};
class B:public A
{
public:
	void foo()
	{
		cout<<"B::foo() is called"<<endl;
	}
};
int main(void){
A*a = new B();
a->foo();  // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
return 00;
}
```

它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。虚函数只能借助于指针或者引用来达到多态的效果。

###### 虚函数的重写

虚函数的重写也叫做虚函数的覆盖,若派生类中有一个和基类完全相同的虚函数(返回值类型相同,函数名相同以及参数列表完全相同),此时我们称该派生类的虚函数重写了基类的虚函数。调用哪个类型的虚函数，取决于基类指针指向或引用的对象是哪种类型的对象。

```c++
#include<iostream>
using namespace std;
class A{
public:
virtual void Print(){
cout<<"A:Print"<<endl;
}
};
//继承A类
class B:public A{
pulic:
virtual void Print(){
cout<<"B::Print"<<endl;
}
};
//继承B类
class C:public B{
virtual void Print(){cout<<"C::Print"<<endl;}
};
//继承A类
class D:pulic A
{
public:
virtual void Print(){cout<<"D:::Print"<<endl;}
};
void Func(A&p){
//通过父类的引用调用虚函数
p.Print();
}
int main(){
A a;B b;C c;D d;
A*pa=&a;
B*pb=&b;
D*pd =&d;
C*pc = &c;
//通过父类的指针调用虚函数
pa->Print(); // a.Print()被调用，输出：A::Print
pa = pb;
pa->Print(); // b.Print()被调用，输出：B::Print
pa = pc;
pa->Print(); // c.Print()被调用，输出：C::Print
pa = pd;
pa->Print(); // d.Print()被调用，输出：D::Print

//通过父类的引用调用虚函数
Func(a);// a.Print()被调用，输出：A::Print
Func(b);// b.Print()被调用，输出：B::Print
Func(c);// c.Print()被调用，输出：C::Print
Func(d); // d.Print()被调用，输出：D::Print

return 0;

}
```

如果不使用基类的指针或引用去调用虚函数，则只会调用基类的虚函数

注意：
在重写基类虚函数时，派生类的虚函数不加virtual关键字也可以构成重写，主要原因是因为继承后基类的虚函数被继承下来了，在派生类中依旧保持虚函数属性。
但是这种写法不是很规范，因为派生类也有可能会被继承，为了区分虚函数，建议在派生类的虚函数前也加上virtual关键字。

注意：
虚函数重写只是重写函数的实现，继承的是父类的接口定义（声明），不会重写函数的缺省参数：
————————————————

######  虚函数重写的例外

协变:父类与子类虚函数返回值类型不同

虚函数要求返回值类型相同，函数名相同以及参数列表完全相同，但是协变是个例外，子类重写基类虚函数时，与基类虚函数返回值类型可以不同。但是**返回值类型也必须满足父子关系**。

```c++
class A{};
class B:public A{};
class Person{
public:
virtual A*Print(){
cout<<"Person::Print"<<endl;
return new A;
}
};
class Student:public Person{
public:
virtual B*Print(){
cout<<"student::Print"<<endl;
return new B;
}
};
void Func(Person&p){
//通过父类的引用调用虚函数
p.Print();
}
int main(){
Person a;
Student b;
Func(a);
Func(b);
}
```

析构函数的重写(基类与派生类析构函数的名字不同)

如果基类的析构函数为虚函数，此时子类的析构函数只要定义，无论是否添加virtual关键字，都与基类的析构函数构成重写。

虽然基类与派生类析构函数名字不同，但是编译器对析构函数的名字进行了特殊的处理，基类和派生类的析构函数构成隐藏。编译后析构函数的名称同一处理成destructor()，其目的是为了实现析构函数的多态。

这也就导致了一个问题，基类与派生类的析构函数名字相同，那指向派生类的基类指针调用的就是基类的析构函数.

由于没有调用派生类的析构函数，派生类如果开辟了资源就会没有释放，最终导致内存泄漏的问题，为了解决这个问题需要把析构函数写为虚函数

**为了不出现内存泄漏的问题，基类的析构函数要加virtual，由于派生类的虚函数不加virtual关键字也可以构成重写，这样在delete就能够实现多态的正确调用析构函数**。



###### C++ 11 override和finall

 final：修饰虚函数，表示该虚函数不能再被重写

```c++
class A{
public:
	virtual void Print()final{
	cout<<"A::Print"<<endl;
	}
};
class B:pulic A{
public:
	virtuall void Print(){
	cout<<"B::Print"<<endl;
	}
}
```

override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错

###### 重载、覆盖(重写)、隐藏(重定义)

重载:两个函数载同一作用域,函数名相同，参数版本不同

重写(覆盖):两个函数分别在基类和派生类的作用域,函数名，参数，返回值都必须相同(协变除外)，两个函数必须是虚函数

重定义(隐藏):两个函数分别在基类和派生类的作用域,函数名相同，两个基类和派生类的同名函数不构成重写就是重定义

###### C++纯虚函数

一、定义
　纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
　virtual void funtion1()=0

二、引入原因
　　1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
　　2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
　　为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

###### 抽象类的介绍

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
（1）抽象类的定义：  称带有纯虚函数的类为抽象类。
（2）抽象类的作用：
抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

**实现继承**： 普通函数的继承是一种实现继承，派生类继承了基类函数的实现，可以使用该函数。
**接口继承**： 虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态。

（3）使用抽象类时注意：
•   抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
•   抽象类是不能定义对象的。

###### 总结：

1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2、虚函数声明如下：virtual ReturnType FunctionName(Parameter)；虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。
定义纯虚函数就是为了让基类不可实例化化
因为实例化这样的抽象数据结构本身并没有意义。
或者给出实现也没有意义
实际上我个人认为纯虚函数的引入，是出于两个目的
1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。
2、为了效率，不是程序执行的效率，而是为了编码的效率。

###### C++多态

多态的概念：通俗来说，就是多种形态， **具体点就是去完成某个行为，当不同的对象去完成时会**

**产生出不同的状态** 。多态分为静态多态和动态多态，静态多态在编译时就已经确定好了，动态多态在运行时才会确定,常见静态多态是函数重载，动态多态则是通过对父类虚函数的重写，通过虚表，达到传入谁的指针就调用谁的函数的目的。

**多态的两个要求:**

 1、被调用的函数必须是虚函数，子类对父类的虚函数进行重写 （重写：三同（函数名/参数/返回值）+虚函数）
 2、父类指针或者引用去调用虚函数。

```c++
class Hero{
public:
	virtual void Attack(Hero*pHero)==0;
	virtual void Hurted(int nPower)==0;
protected:
	int m_nPower=1;
	int m_nLieValue=10;
};
class DAJI:public Hero{
public:
	virtual void Attack(Hero*pHero){
	pHero->Hurted(m_nPower);
	}
	void Hurted(int nPower)
    {
        m_nLifeValue -= nPower;
    }
}
```

###### 多态的实现原理

「多态」的关键在于通过基类指针或引用调用一个虚函数时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。

```c++
class A
{
public:
    int i;
    virtual void Print() { } // 虚函数
};

class B
{
public:
    int n;
    void Print() { }
};

int main()
{
    A a;
    B b;
    cout << sizeof(a) << "," << sizeof(b);
    return 0;
}

```

A对象当中除了i成员外，实际上还有一个指针`_vfptr`放在对象的前面（有些平台可能会放到对象的最后面，这个跟平台有关）。

对象中的这个指针叫做虚函数表指针，简称虚表指针，虚表指针指向一个虚函数表，简称虚表，每一个含有虚函数的类中都至少有一个虚表指针。

```c++
#include <iostream>
using namespace std;
//父类
class Base
{
public:
	//虚函数
	virtual void Func1()
	{
		cout << "Base::Func1()" << endl;
	}
	//虚函数
	virtual void Func2()
	{
		cout << "Base::Func2()" << endl;
	}
	//普通成员函数
	void Func3()
	{
		cout << "Base::Func3()" << endl;
	}
private:
	int _b = 1;
};
//子类
class Derive : public Base
{
public:
	//重写虚函数Func1
	virtual void Func1()
	{
		cout << "Derive::Func1()" << endl;
	}
private:
	int _d = 2;
};
int main()
{
	Base b;
	Derive d;
	return 0;
}

```

对象中的这个指针叫做虚函数表指针，简称虚表指针，虚表指针指向一个虚函数表，简称虚表，每一个含有虚函数的类中都至少有一个虚表指针

```c++
#include <iostream>
using namespace std;
//父类
class Base
{
public:
	//虚函数
	virtual void Func1()
	{
		cout << "Base::Func1()" << endl;
	}
	//虚函数
	virtual void Func2()
	{
		cout << "Base::Func2()" << endl;
	}
	//普通成员函数
	void Func3()
	{
		cout << "Base::Func3()" << endl;
	}
private:
	int _b = 1;
};
//子类
class Derive : public Base
{
public:
	//重写虚函数Func1
	virtual void Func1()
	{
		cout << "Derive::Func1()" << endl;
	}
private:
	int _d = 2;
};
int main()
{
	Base b;
	Derive d;
	return 0;
}

```

虚表当中存储的就是虚函数的地址，因为父类当中的Func1和Func2都是虚函数，所以父类对象b的虚表当中存储的就是虚函数Func1和Func2的地址。

而子类虽然继承了父类的虚函数Func1和Func2，但是子类对父类的虚函数Func1进行了重写，因此，子类对象d的虚表当中存储的是父类的虚函数Func2的地址和重写的Func1的地址。这就是为什么虚函数的重写也叫做覆盖，覆盖就是指虚表中虚函数地址的覆盖，重写是语法的叫法，覆盖是原理层的叫法。

其次需要注意的是：Func2是虚函数，所以继承下来后放进了子类的虚表，而Func3是普通成员函数，继承下来后不会放进子类的虚表。此外，虚函数表本质是一个存虚函数指针的指针数组，一般情况下会在这个数组最后放一个nullptr。
**虚表存在哪里**

```c++
//存在代码段(堆栈是动态开辟的，因此只剩静态区和代码段)
Base b1;
Base b2;
char *str = '123456';
int *p = new int;
printf("虚表指针:%p\n",*((int*)&b1));//虚表指针存在对象里面的头四个字节
printf('栈地址:%p\n',&str);//cout打印char*会当作字符串去打印
printf("堆地址%p\n",p);
printf("静态区地址%p\n",&val);
printf("代码段地址:%p\n",str);
//结果证明虚表存在代码段

```

**虚表是什么阶段初始化的**

虚表指针在构造函数阶段（初始化列表）填入到对象中，虚表则是在编译时就生成好了。
虚表里面放的是虚函数地址，虚函数和普通函数一样，编译完成以后，都是放在代码段中。
一个类中所有的虚函数，都会放在虚表中。
子类会将父类的虚表拷贝一份，然后用重写的虚函数地址覆盖掉原来虚表中的函数地址，因此虚函数的重写，也叫虚函数的覆盖。
**虚表如何实现多态**

当满足多态条件以后，父类的指针或引用调用虚函数时，不是编译时确定的，而是运行时到指向的对象中的虚表中去找对应的虚函数调用，并且引用的底层也是由指针实现，父类在指向子类时会发生切片。所以指针指向父类的对象，调用的就是父类的虚函数，指向的是子类对象，调用的就是子类的虚函数。

```c++
#include <iostream>
using namespace std;
//父类
class Person
{
public:
	virtual void BuyTicket()
	{
		cout << "买票-全价" << endl;
	}
	int _p = 1;
};
//子类
class Student : public Person
{
public:
	virtual void BuyTicket()
	{
		cout << "买票-半价" << endl;
	}
	int _s = 2;
};
int main()
{
	Person Mike;
	Student Johnson;
	Johnson._p = 3; //以便观察是否完成切片
	Person* p1 = &Mike;
	Person* p2 = &Johnson;
	p1->BuyTicket(); //买票-全价
	p2->BuyTicket(); //买票-半价
	return 0;
}

```

如果使用父类对象而不是父类指针时，切片得到部分成员变量后，会调用父类的拷贝构造函数对那部分成员变量进行拷贝构造，虚表指针是不会拷贝的，否则就会发生混乱（父类的虚表里有子类的虚函数），因此拷贝构造出来的父类对象p1和p2当中的虚表指针指向的都是父类对象的虚表。因为同类型的对象共享一张虚表，他们的虚表指针指向的虚表是一样的。

1. inline可以是虚函数吗？

   可以，在VS之下，如果构成多态，编译器会舍弃inline属性，这个函数就不是内联函数了，因为内联函数会被展开，是没有地址的。而虚函数会将其地址放入至虚表之中。

   如果不构成多态直接调用，则内联展开。**在类里面定义的函数默认内联**。

2. 静态成员可以是虚函数吗？

   不能，静态成员没有this指针，也就是没有对象，没有对象代表没有虚表指针指向虚表(虚表指针是存储在对象之中的)。

3. 构造函数可以是虚函数吗？

   不可以。
   定义虚函数的目的是构成多态，多态调用要去对象的虚表中找到虚函数。因为虚函数表指针是在构造函数初始化阶段才初始化的(将虚函数地址填入虚函数表之中)。所以在构造函数阶段，对应的虚表指针还没有初始化，自然无法找到虚表中的构造函数。

4. 对象访问普通函数快还是虚函数更快？

   不构成多态的时候，在编译时就确定了如何调用，因此是一样快的。
   构成多态时，访问普通函数快，因为访问虚函数首先需要去对象之中找到指针，然后通过指针找到虚表之中去寻找函数地址。

5. 虚函数表示在什么阶段、在哪里生成的？

   虚函数表是在编译阶段生成的，一般情况下存在代码段。

6. C++菱形继承的问题？虚继承的原理？

   菱形虚拟继承因为子类对象当中会有两份父类的成员，因此会导致数据冗余和二义性的问题。
   虚继承对于相同的虚基类在对象当中只会存储一份，若要访问虚基类的成员需要通过虚基表获取到偏移量，进而找到对应的虚基类成员，从而解决了数据冗余和二义性的问题。

7. 什么是抽象类，抽象类的作用？

   抽象类不能实例化出对象，描述的事物没有对应的实体，另外抽象类体现出了接口继承的关系。

   **子类的虚函数为私有成员**

   按理来讲，一个类的私有函数是无法在类外访问的，但是如果其为虚函数，则可以被基类指针或引用访问。这主要是因为虚表中有虚函数的地址，该虚函数在父类中是公有的，那在子类中也还是公有的，如果把父类中的函数设为私有，那就无法访问。

   **虚函数并不一定就是动态绑定**

   首先，动态绑定的前提是**引用或指针指向的对象不确定是基类还是派生类**,动态多态是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数。

   并且，如果虚函数直接通过对象来运行，则是在编译时就确定地址，如果通过指针或引用来运行，则是在运行时确定地址。

   **当多继承时重写同一个函数，会把最终跳转地址放在先继承的虚表中**

   ```c++
   #include <iostream>
   using namespace std;
   //父类
   class Base1 {
   public:
   	virtual void func1() { cout << "Base1::func1" << endl; }
   	virtual void func2() { cout << "Base1::func2" << endl; }
   	int b1;
   private:
   };
   class Base2 {
   public:
   	virtual void func1() { cout << "Base2::func1" << endl; }
   	virtual void func2() { cout << "Base2::func2" << endl; }
   private:
   	int b2;
   };
   class Derive : public Base1, public Base2
   {
   public:
   	//重写func1
   	virtual void func1()
   	{
   		cout << "Derive::func1()" << endl;
   	}
   private:
   	int _d = 2;
   };
   
   int main()
   {
   	Derive d;
   	Base1* p1 = &d;
   	Base2* p2 = &d;
   
   	p1->func1();
   	p2->func1();
   
   	return 0;
   }
   
   ```

**编译器处理虚函数表应该如何处理 **
 
对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤：

拷贝基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表

当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基类

查看派生类中是否写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派⽣类是否有⾃身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中。

Derived *pd = new D(); B *pb = pd; C *pc = pd; 其中 pb， pd， pc 的指针位置是不同的，要注意的是派⽣类的⾃身的内容要追加在主基类的内存块后。



   
